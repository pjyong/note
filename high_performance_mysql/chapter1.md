# MySQL的架构与历史

和其他数据库系统相比，MySQL可以在不同场景中应用并发挥好的作用，它可以通过配置在不同的硬件上运行得很好，也支持不同的数据类型。当然，最与众不同的是它的存储引擎架构，一种处理和存储分离的设计，使得可以在使用时根据性能、特性以及其它需求来选择最合适的方式。

## 1.1-MySQL逻辑架构

### MySQL三层架构

* 连接/线程处理。这个并不是MySQL所独有，大多数基于网络的客户端/服务器的工具都有类似的架构，比如连接处理、授权认证和安全等等。
* 查询缓存、解析器、优化器。MySQL的核心服务功能就在这层，还有所有的内置函数实现、存储过程、触发器、视图等。
* 存储引擎。存储引擎不会解析SQL，但它有提供几十个底层函数来响应上层的请求，比如执行“开始一个事务”或“根据主键提取一行记录”。

### 连接管理与安全性

* 每个客户端连接都会在服务器进程中拥有一个线程，所有这个连接的查询只在这个线程中执行。服务器会缓存线程，它不会为每个连接新建或销毁线程。
* 当客户端连接到MySQL时，需要进行认证。认证成功之后，每个具体的操作MySQL都会检查该客户端是否有权限执行。

### 优化与执行

* MySQL优化器会解析用户的SQL，并对其各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引。用户也可以通过特殊的关键字提示优化器，影响它的决策，比如子表查询，连接这些关键字。用户也可以请求优化器explain它的具体步骤。
* 优化器并不关心表用的是什么存储引擎，但存储引擎对于优化查询是有影响的。这个就需要用户自己来完成优化。
* 对于SELECT语句，在解析查询之前，服务器会先检查**查询缓存(Query Cache)**，如果能在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

## 1.2-并发控制

### 读写锁

读写锁也称为共享锁(shared lock)和排他锁(exclusive lock)。读锁是相互不阻塞的，多个客户端在同一时刻读取同一个资源，互相不干扰。但写锁会阻塞其他的写锁和读锁，只有这样才能确保在给定的时间内，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

下面是锁的一些测试(基于innodb)：

#### 先创建共享锁
```
/\*客户端1\*/
set autocommit = 0;
SELECT * FROM table1 where name= 'abc' lock in share mode
/\*客户端2\*/
SELECT * FROM table1 where name= 'abc' lock in share mode /\*不阻塞\*/
SELECT * FROM table1 where name= 'abc' for update /\*阻塞\*/
update table1  set address = 'hubei' where name='abc' /\*阻塞\*/
```

#### 先创建排它锁
```
/\*客户端1\*/
set autocommit = 0;
SELECT * FROM table1 where name= 'abc' for update
/\*客户端2\*/
SELECT * FROM table1 where name= 'abc' lock in share mode /\*阻塞\*/
SELECT * FROM table1 where name= 'abc' for update /\*阻塞\*/
update table1  set address = 'hubei' where name='abc' /\*阻塞\*/
```

**另外得补充一点的是，如果name有索引，只会锁行，否则就会锁表。**
