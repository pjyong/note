# MySQL高级特性

## 7.1-分区表

使用分区表的场景：
* 表非常大无法放在内存当中，或者只在表的最后有热点数据，其它均是历史数据
* 分区表的数据更容易维护。例如想批量删除大量数据可以使用清除整个分区的方式，另外还可以对一个独立分区进行优化、检查、修复等操作
* 分区表可以分布在不同的物理硬件上，从而高效利用多个硬件设备
* 可以用分区表避免某些特殊的瓶颈。例如Innodb的单个索引的互斥访问、ext3文件系统的inode锁竞争等
* 如果需要，可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好

分区表本身限制：
* 一个表最多只能有1024个分区
* 在MySQL 5.1中，分区表达式必须是整数，或者是返回整数的表达式。在MySQL 5.5中，某些场景直接使用列来进行分区
* 如果分区字段有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
* 分区表中无法使用外键约束

### 分区表的原理
分区表是由多个底层表组成，我们可以直接访问各个分区。存储引擎管理各个底层表和管理普通表一样。分区表的索引只是在各个底层表上各自加上了一个完全相同的索引。

* SELECT
  * 当查询一个分区表的时候，分区层先打开并锁住所有底层表，优化器先判断是否可以过滤部分分区，然后访问各个分区的数据
* INSERT
  * 当写入记录时，分区层先打开并锁住所有底层表，然后确定哪个分区接收这条记录，再将记录写入对应底层表
* DELETE
  * 同上...找到对应底层表删除数据
* UPDATE
  * 同上...判断更新后的数据属于哪个分区并写入，再对原数据所在的底层表进行删除操作

Innodb在分区层是不会锁表的，还是行锁。

### 分区表的类型

* 范围分区。分区表达式可以是列，也可以使包含列的表达式
* 键值、哈希和列表分区
* 数学模函数分区。例如对日期做模7的运算
* HASH(id DIV 1000000)，这就为100万数据建立一个分区

### 如何使用分区表

例子：希望查询最近几个月的记录，这大约有10亿条。如何查询这个表？如何更高效？

* 肯定不能全表扫描
* 放在内存里也不可能
* 也不希望使用索引，因为索引在空间和维护上的消耗太大。即使真的使用索引，你会发现数据并不是按照想要的方式聚集的，而且产生大量碎片，最终导致一个查询产生成千上万的随机IO，应用程序也随之僵死

我们可以这样做：
* 全量扫描数据，不要任何索引。使用简单的分区方式存放表，不要任何索引，只要在where条件里定位到少数分区，顺序扫描效率是很高的。必须要将扫描分区的个数限制在一个很少的数量。
* 索引数据，并分离热点。可以单独给这些热点建一个独立分区。

### 分区在哪些情况下会出问题

* NULL值会使分区过滤无效
* 分区列和索引列不匹配
* 选择分区的成本可能很高
* 打开并锁住所有的底层表的成本可能很高
* 维护分区的成本可能很高

### 用来分区的字段必须是主键的一部分

```
ALTER TABLE `masterdb1`.`sbtest1` PARTITION BY RANGE(k DIV 100000)
(
    PARTITION part0 VALUES LESS THAN (2),
    PARTITION part1 VALUES LESS THAN (3),
    PARTITION part2 VALUES LESS THAN (4),
    PARTITION part3 VALUES LESS THAN (5),
    PARTITION part4 VALUES LESS THAN (6),
    PARTITION part5 VALUES LESS THAN (7),
    PARTITION part6 VALUES LESS THAN (8),
    PARTITION part7 VALUES LESS THAN (9),
    PARTITION part8 VALUES LESS THAN (MAXVALUE)
);
```

上面的分区表，在查询`k > 800000`时并没有过滤分区，所以不要使用列的表达式，而是使用列。不必单独为分区字段添加索引。
