# 创建高性能的索引

索引优化是查询性能优化最有效的手段

## 5.1-索引基础

### B-Tree索引

* 节点页和叶子页组成。节点页是由多个_key+指针(指向子页)_组成。叶子页是由多个_val_和一个_指针(指向下一个叶子页)_组成，其中val必须在父页指针区前后两个key范围之内。
* 每一个叶子页到根的距离相同，单个叶子都指向每行数据存储(聚簇索引:innodb会将数据直接存放在单个叶子里面)。
* 数的深度和表的大小直接相关。

这里就可以解释多列索引的最左匹配了。

### 适用B-Tree索引的查询类型

* 全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值
* 精确匹配某一列并范围匹配另一列
* 只访问索引的查询

### 哈希索引

哈希索引基于哈希表实现，只有精确匹配到所有列的查询才有效。对于每行数据，存储引擎都会对索引列计算一个哈希码，然后将哈希码存入索引，同时在哈希表中保存指向数据的指针。

MySQL只有Memory引擎显式支持哈希索引(默认索引类型)。Memory引擎也支持B-Tree索引。如果出现Hash冲突，则将多个行指针存放在一个Hash条目里。

Innodb有一个特殊功能叫做“自适应哈希索引”，它发现某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上创建一个Hash索引。

#### 创建自定义Hash索引

实际上是一个伪Hash索引，基于B-Tree。比如：我们要根据url查询，url一般都很长，如果用B-Tree建了索引，存储的内容就会很大。我们可以考虑删掉索引，新增一个被索引的url_crc列，`where url = 'XXX' AND url_crc = CRC32('XXX')`，这样查询就会快很多。这里我们得注意几点。

* 为什么不用md5,sha1？主要是因为它们生成的hash太长，浪费大量空间，它们是为最大限度消除冲突，但我们这里不需要
* 如何维护url_crc列？我们得创建两个MySQL触发器当数据行插入或修改时，来维护这个字段
* 如果数据表太大，可以考虑实现简单的64位Hash

## 5.2-索引的优点

* 大大减少服务器需要扫描的数据量
* 可以帮助服务器避免排序和临时表
* 可以将随机I/O变成顺序I/O

### 索引是最好的解决方案？

* 对于小型表，全表扫描更有效
* 对于中到大型表，索引非常有效
* 对于特大型表，建立和使用索引的代价非常高。我们需要“分区”直接查询一组数据，而不是一条一条匹配。如果表的数量特别多，我们可以建立一个元数据信息表。比如哪个用户的信息存在哪个数据表中。

## 5.3-高性能索引策略

### 独立的列

不要在查询列上使用任何函数或者算法(可以在查询值上这么做)。

### 前缀索引和索引选择性

前缀索引就是给列的部分字符串建索引。索引选择性就是不重复的索引值和数据表记录总数的比值。当这个比值为1时，查询性能最好。

如何给某列建前缀索引？我们GROUP该列取每个值出现的次数作为参考标准，然后分别GROUP该列前3个字符，该列前4个字符...直到这个长度出现的次数比较接近参考标准，就是我们要的数值。

### 多列索引

MySQL针对多个索引查询，会执行索引合并策略，有时候是一种优化，但实际情况是索引建得很糟糕。

* 当出现服务器做相交操作时(AND)，这意味需要一个多列索引，而不是多个单列索引
* 当出现服务器做联合操作时(OR)，这意味耗费CPU和内存在缓存、排序和合并上，尤其是某些列选择性不高，会扫描并返回大量数据
* 最重要的是，优化器并不会把上面这些耗时计入“查询成本”里，明明全表查询更快，它还固执地按索引来

### 选择合适的索引列顺序

当不需要考虑分组和排序时，将选择性最高的列放在最前面。我们可能根据运行频率最高的查询来调整索引的顺序。

某些特殊条件的查询，我们应该尽量避免。比如，我们有一个公司账号是专门用来给所有账号发送消息的，那么我们在查询某个账号的发送记录时，应该在程序上避免查公司账号。

### 聚簇索引

它是一种存储结构，将数据直接存放在单个叶子里面。因为无法将数据行存在两个不同的地方，所以一个表只能有一个聚簇索引。

### 覆盖索引

我们可以使用“延迟关联”来实现覆盖索引。
```
/*错误做法*/
SELECT * FROM orders ORDER BY Rating LIMIT 10000,0
/*正确做法*/
SELECT * FROM orders INNER JOIN (
  SELECT ID FROM orders ORDER BY Rating LIMIT 10000,0
) AS x USING(ID)
```

### 冗余和重复索引

在扩展已有的索引会导致其变得太大，影响其他使用该索引的性能时，我们可以考虑添加冗余索引。

### 索引和锁

## 5.4-索引案例学习

如果MySQL使用某个索引的范围查询，也就无法使用另一个索引或者该索引的后续字段。

### 多用IN来减少索引。

性别需要建索引吗？
如果绝大多数查询都涉及到性别，那就将性别作为索引的前缀(参考“索引覆盖”)。更重要的是，这样也没什么坏处。针对没有查询性别的SQL，可以在WHERE后面加上`SEX IN ('m', 'f')`来让SQL选择该索引。

### 优化排序
