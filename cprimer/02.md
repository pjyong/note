# Chapter 2 - pointers, refrence

## 2.1 refrence 引用

引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。

	int m; 
	int &n = m;

n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。 

**引用的规则：**

- 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 
- 不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 
- 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。 

以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。

	int i = 5; 
	int j = 6; 
	int &k = i; 
	k = j; // k和i的值都变成了6; 

**引用的主要功能是传递函数的参数和返回值**。

C++语言中，函数的参数和返回值的传递方式有三种：**值传递、指针传递和引用传递**。 

### (1) 以下是"值传递"的示例程序

由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。

	void Func1(int x) 
	{ 
		x = x + 10; 
	} 
	... 
	int n = 0; 
	Func1(n); 
	cout << "n = " << n << endl; // n = 0 

### (2) 以下是"指针传递"的示例程序

由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。

	void Func2(int *x) 
	{ 
		(* x) = (* x) + 10; 
	} 
	... 
	int n = 0; 
	Func2(&n); 
	cout << "n = " << n << endl; // n = 10 

### (3) 以下是"引用传递"的示例程序

由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。
 
	void Func3(int &x) 
	{ 
		x = x + 10; 
	} 
	... 
	int n = 0; 
	Func3(n); 
	cout << "n = " << n << endl; // n = 10 

对比上述三个示例程序，**会发现"引用传递"的性质象"指针传递"，而书写方式象"值传递"**。 

实际上"引用"可以做的任何事情"指针"也都能够做，为什么还要"引用"这东西？ 
答案是"用适当的工具做恰如其分的工作"。 

指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。 

如果的确只需要借用一下某个对象的"别名"，那么就用"引用"，而不要用"指针"，以免发生意外。

## 导航
* [目录](00.md)
* 上一章：[Chapter 1 - const, inline，static, this](01.md)
* 下一章：[Chapter 3 - char*, char[], string](03.md)