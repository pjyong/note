# PHP Socket

## C10K的难题
进入Web2.0，用户需要与服务器保持TCP连接进行实时数据交互，C10K的问题才暴露出来了。最初的服务器都是基于进程/线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么操作系统是无法承受的

## 阻塞/非阻塞
这两个概念是针对IO过程中进程的状态来说的，阻塞IO是指调用结果返回之前，当前线程会被挂起；相反，非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回

## 同步/异步
这两个概念是针对调用如果返回结果来说的，所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回；相反，当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者

## 多路复用
对于Socket来说，应该说能同时处理多个连接的模型都应该被称为多路复用。一个进程处理多个tcp连接

## Epoll异步非阻塞
不需要购买很多服务器，有几台服务器就可以服务大量用户。Nginx，libevent，node.js这些就是Epoll时代的产物

## 协程coroutine
在node.js中，写个非阻塞可能嵌套回调几十层，而使用coroutine就可以完全避免。这个技术本质上也是异步非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。比如调用 client->recv() 等待接收数据时，就像阻塞代码一样写。实际上是底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行
